{"version":3,"file":"html-parse-stringify.modern.js","sources":["../src/parse-tag.js","../src/parse.js","../src/stringify.js","../src/index.js"],"sourcesContent":["import lookup from 'void-elements'\nconst attrRE = /\\s([^'\"/\\s><]+?)[\\s/>]|([^\\s=]+)=\\s?(\".*?\"|'.*?')/g\n\nexport default function stringify(tag) {\n  const res = {\n    type: 'tag',\n    name: '',\n    voidElement: false,\n    attrs: {},\n    children: [],\n  }\n\n  const tagMatch = tag.match(/<\\/?([^\\s]+?)[/\\s>]/)\n  if (tagMatch) {\n    res.name = tagMatch[1]\n    if (\n      lookup[tagMatch[1].toLowerCase()] ||\n      tag.charAt(tag.length - 2) === '/'\n    ) {\n      res.voidElement = true\n    }\n\n    // handle comment tag\n    if (res.name.startsWith('!--')) {\n      const endIndex = tag.indexOf('-->')\n      return {\n        type: 'comment',\n        comment: endIndex !== -1 ? tag.slice(4, endIndex) : '',\n      }\n    }\n  }\n\n  const reg = new RegExp(attrRE)\n  let result = null\n  for (;;) {\n    result = reg.exec(tag)\n\n    if (result === null) {\n      break\n    }\n\n    if (!result[0].trim()) {\n      continue\n    }\n\n    if (result[1]) {\n      const attr = result[1].trim()\n      let arr = [attr, '']\n\n      if (attr.indexOf('=') > -1) {\n        arr = attr.split('=')\n      }\n\n      res.attrs[arr[0]] = arr[1]\n      reg.lastIndex--\n    } else if (result[2]) {\n      res.attrs[result[2]] = result[3].trim().substring(1, result[3].length - 1)\n    }\n  }\n\n  return res\n}\n","import parseTag from './parse-tag'\n\nconst tagRE = /<[a-zA-Z0-9\\-\\!\\/](?:\"[^\"]*\"|'[^']*'|[^'\">])*>/g\nconst whitespaceRE = /^\\s*$/\n\n// re-used obj for quick lookups of components\nconst empty = Object.create(null)\n\nexport default function parse(html, options) {\n  options || (options = {})\n  options.components || (options.components = empty)\n  const result = []\n  const arr = []\n  let current\n  let level = -1\n  let inComponent = false\n\n  // handle text at top level\n  if (html.indexOf('<') !== 0) {\n    var end = html.indexOf('<')\n    result.push({\n      type: 'text',\n      content: end === -1 ? html : html.substring(0, end),\n    })\n  }\n\n  html.replace(tagRE, function (tag, index) {\n    if (inComponent) {\n      if (tag !== '</' + current.name + '>') {\n        return\n      } else {\n        inComponent = false\n      }\n    }\n    const isOpen = tag.charAt(1) !== '/'\n    const isComment = tag.startsWith('<!--')\n    const start = index + tag.length\n    const nextChar = html.charAt(start)\n    let parent\n\n    if (isComment) {\n      const comment = parseTag(tag)\n\n      // if we're at root, push new base node\n      if (level < 0) {\n        result.push(comment)\n        return result\n      }\n      parent = arr[level]\n      parent.children.push(comment)\n      return result\n    }\n\n    if (isOpen) {\n      level++\n\n      current = parseTag(tag)\n      if (current.type === 'tag' && options.components[current.name]) {\n        current.type = 'component'\n        inComponent = true\n      }\n\n      if (\n        !current.voidElement &&\n        !inComponent &&\n        nextChar &&\n        nextChar !== '<'\n      ) {\n        current.children.push({\n          type: 'text',\n          content: html.slice(start, html.indexOf('<', start)),\n        })\n      }\n\n      // if we're at root, push new base node\n      if (level === 0) {\n        result.push(current)\n      }\n\n      parent = arr[level - 1]\n\n      if (parent) {\n        parent.children.push(current)\n      }\n\n      arr[level] = current\n    }\n\n    if (!isOpen || current.voidElement) {\n      if (\n        level > -1 &&\n        (current.voidElement || current.name === tag.slice(2, -1))\n      ) {\n        level--\n        // move current up a level to match the end tag\n        current = level === -1 ? result : arr[level]\n      }\n      if (!inComponent && nextChar !== '<' && nextChar) {\n        // trailing text node\n        // if we're at the root, push a base text node. otherwise add as\n        // a child to the current node.\n        parent = level === -1 ? result : arr[level].children\n\n        // calculate correct end of the content slice in case there's\n        // no tag after the text node.\n        const end = html.indexOf('<', start)\n        let content = html.slice(start, end === -1 ? undefined : end)\n        // if a node is nothing but whitespace, collapse it as the spec states:\n        // https://www.w3.org/TR/html4/struct/text.html#h-9.1\n        if (whitespaceRE.test(content)) {\n          content = ' '\n        }\n        // don't add whitespace-only text nodes if they would be trailing text nodes\n        // or if they would be leading whitespace-only text nodes:\n        //  * end > -1 indicates this is not a trailing text node\n        //  * leading node is when level is -1 and parent has length 0\n        if ((end > -1 && level + parent.length >= 0) || content !== ' ') {\n          parent.push({\n            type: 'text',\n            content: content,\n          })\n        }\n      }\n    }\n  })\n\n  return result\n}\n","function attrString(attrs) {\n  const buff = []\n  for (let key in attrs) {\n    buff.push(key + '=\"' + attrs[key] + '\"')\n  }\n  if (!buff.length) {\n    return ''\n  }\n  return ' ' + buff.join(' ')\n}\n\nfunction stringify(buff, doc) {\n  switch (doc.type) {\n    case 'text':\n      return buff + doc.content\n    case 'tag':\n      buff +=\n        '<' +\n        doc.name +\n        (doc.attrs ? attrString(doc.attrs) : '') +\n        (doc.voidElement ? '/>' : '>')\n      if (doc.voidElement) {\n        return buff\n      }\n      return buff + doc.children.reduce(stringify, '') + '</' + doc.name + '>'\n    case 'comment':\n      buff += '<!--' + doc.comment + '-->'\n      return buff\n  }\n}\n\nexport default function (doc) {\n  return doc.reduce(function (token, rootEl) {\n    return token + stringify('', rootEl)\n  }, '')\n}\n","import parse from './parse'\nimport stringify from './stringify'\n\nexport default {\n  parse,\n  stringify,\n}\n"],"names":["attrRE","stringify","tag","res","type","name","voidElement","attrs","children","tagMatch","match","lookup","toLowerCase","charAt","length","startsWith","endIndex","indexOf","comment","slice","reg","RegExp","result","exec","trim","attr","arr","split","lastIndex","substring","tagRE","whitespaceRE","empty","Object","create","buff","doc","content","key","push","join","attrString","reduce","parse","html","options","components","current","level","inComponent","end","replace","index","isOpen","isComment","start","nextChar","parent","parseTag","undefined","test","token","rootEl"],"mappings":"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"}