"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const services_1 = require("./services");
const types_1 = require("./types");
const fs = __importStar(require("fs"));
const glob = __importStar(require("glob"));
const path = __importStar(require("path"));
const gonzales_pe_sl_1 = require("gonzales-pe-sl");
const config_1 = __importDefault(require("sass-lint/lib/config"));
const rules_1 = __importDefault(require("sass-lint/lib/rules"));
function autoFixSassFactory(config) {
    const { logger } = config;
    const _getRules = config.slRules || rules_1.default;
    const _getConfig = config.slConfig || config_1.default;
    const patternsToInclude = typeof config.files.include === 'string'
        ? [config.files.include]
        : config.files.include;
    return function* autoFixSass(options) {
        for (const pattern of patternsToInclude) {
            const files = glob.sync(pattern, {
                ignore: config.files.ignore,
            });
            for (const filename of files) {
                const content = fs.readFileSync(filename).toString();
                if (content !== null && content !== undefined && content.length > 0) {
                    const fileExtension = path
                        .extname(filename)
                        .substr(1)
                        .toLowerCase();
                    if (isValidExtension(fileExtension)) {
                        let ast;
                        try {
                            ast = gonzales_pe_sl_1.parse(content, {
                                syntax: fileExtension,
                            });
                        }
                        catch (e) {
                            logger.warn('parse', filename, e);
                            return;
                        }
                        const rules = _getRules(_getConfig(options));
                        const filteredRules = rules.filter((rule) => config.resolvers[rule.rule.name]);
                        for (const rule of filteredRules) {
                            const { name } = rule.rule;
                            let resolver;
                            try {
                                resolver = createModule({
                                    name,
                                    ast,
                                    rule,
                                });
                            }
                            catch (e) {
                                services_1.SentryService.reportIncident(e);
                                logger.warn('resolver', `Module '${name}' doesn't exist.`);
                                return;
                            }
                            try {
                                const detects = rule.rule.detect(ast, rule);
                                if (detects.length > 0) {
                                    logger.verbose('fix', `Running resolver "${name}" on "${filename}"`);
                                    ast = resolver.fix(detects);
                                    yield {
                                        ast,
                                        filename,
                                        rule,
                                    };
                                }
                            }
                            catch (e) {
                                if (!config.options.optOut) {
                                    services_1.SentryService.reportIncident(e);
                                }
                                // TODO: Friendly way to inform user that an unexpected error occured
                                logger.warn('error', e);
                            }
                        }
                    }
                }
            }
        }
    };
}
exports.autoFixSassFactory = autoFixSassFactory;
function createModule({ ast, name, rule, }) {
    const _module = require(`./resolvers/${name}`).default;
    return new _module(ast, rule);
}
exports.createModule = createModule;
function isValidExtension(fileExtension) {
    return fileExtension in types_1.ValidFileType;
}
exports.isValidExtension = isValidExtension;
